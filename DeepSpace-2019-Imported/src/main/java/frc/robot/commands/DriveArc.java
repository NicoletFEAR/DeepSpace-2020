// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;

import edu.wpi.first.wpilibj.GenericHID;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import frc.robot.Robot;
import frc.robot.RobotMap;

/**
 * Command handling driving in an arc
 */
public class DriveArc extends Command {
    double x;
    double y;
    double theta;

    double z;
    double r;

    double circR;
    double circL;

    double error;
    double speed;
    double derivative;
    double integral;
    double previousError;

    boolean complete;
    boolean left;

    // public DriveArc() {
    // // requires(Robot.driveTrain);
    // this(-24, 48, 60);
    // }

    public DriveArc(double x, double y, double theta, double distOffset) {
        requires(Robot.driveTrain);
        this.x = x - distOffset * Math.cos(Math.toRadians(90 - theta));
        this.y = (y * 12) - distOffset * Math.sin(Math.toRadians(90 - theta));
        this.theta = -theta; // inverted
        
        // if (x == 0) {
        //     this.x = 0.01;
        // }
        // if (y == 0) {
        //     this.y = 0.01;
        // }
        // if (theta == 0) {
        //     this.theta = 0.01;
        // }

        setInterruptible(true);
    }

    public double TicksToRevolution(double numberOfTicks) {
        // System.out.println("TicksToRevolution()");
        double percentRotation = numberOfTicks / RobotMap.WHEEL_TICKS_PER_REVOLUTION;
        return percentRotation;
    }

    public double RevolutionsToInches(double percentRotation) {
        // System.out.println("RevolutionToInches()");
        double distanceTraveled = (2 * Math.PI * RobotMap.WHEEL_RADIUS) * percentRotation;
        return distanceTraveled;
    }

    @Override
    protected void initialize() {
        complete = false;
        
        //reset navX for tuning arc
        Robot.navX.reset();

        double prefferedLength = y / Math.cos(Math.toRadians(theta));
        double currentLength = Math.sqrt(x * x + y * y);


        double leftRadius = 0.0;
        double rightRadius = 0.0;
        boolean turnBool = false;
        if (currentLength > prefferedLength) {
            // rotate to the right, arcing to the left
            z = -2 * (Math.toDegrees(Math.tanh(x / y)) - theta);
            double degreesToRotate = theta + z;
            
            while (!turnBool) {
                turnBool = Robot.driveTrain.turnToAngle(degreesToRotate);
                SmartDashboard.putString("Turning", "Turn Left");
            }

            double radius = (1.0 / 2 * Math.sqrt(x * x + y * y)) / (Math.sin(Math.toRadians(.5 * z)));
            leftRadius = radius - 1.0 * RobotMap.DISTANCE_BETWEEN_TRACKS;
            rightRadius = radius + 1.0 * RobotMap.DISTANCE_BETWEEN_TRACKS;
        } else {
            // rotate to the left, arcing to the right
            z = 2 * (theta - Math.toDegrees(Math.tanh(x / y)));
            double degreesToRotate = theta - z;

            while (!turnBool) {
                turnBool = Robot.driveTrain.turnToAngle(degreesToRotate);
                SmartDashboard.putString("Turning", "Turn Right");
            }

            double radius = (1.0 / 2 * Math.sqrt(x * x + y * y)) / (Math.sin(Math.toRadians(.5 * z)));
            leftRadius = radius + 1.0 / 2 * RobotMap.DISTANCE_BETWEEN_TRACKS;
            rightRadius = radius - 1.0 / 2 * RobotMap.DISTANCE_BETWEEN_TRACKS;
        }

        circL = leftRadius * 2 * Math.PI * z / 360;
        circR = rightRadius * 2 * Math.PI * z / 360;

        SmartDashboard.putString("Turning", "done turning");
        
        // if (!Robot.driveTrain.isReversed()) {
        //     double tmp = circL;
        //     circL = -circR;
        //     circR = -tmp;
        // }

        // reset the encoders
        Robot.driveTrain.resetEncoders();
        
    } // end of init, go to execute

    @Override
    protected void execute() {
        SmartDashboard.putNumber("CircL", circL);
        SmartDashboard.putNumber("CircR", circR);
        SmartDashboard.putNumber("Speed", speed);

        if (Math.abs(circL) > Math.abs(circR)) { 
            left = true;
            arcDriveRacing(circL);
            double leftSpeed = speed;
            double rightSpeed = speed * circR / circL;
            double average = (leftSpeed + rightSpeed) / 2;
            Robot.driveTrain.RacingDrive(-average, -(leftSpeed - average));
        } else {
            left = false;
            arcDriveRacing(circR);
            double rightSpeed = speed;
            double leftSpeed = speed * circL / circR;
            double average = (leftSpeed + rightSpeed) / 2;
            Robot.driveTrain.RacingDrive(-average, (rightSpeed - average));
        }
        SmartDashboard.putBoolean("Complete arc drive", complete);

    }

    double currentLocation;

    // Arc length should be in inches
    public void arcDriveRacing(double arcLength) {
        SmartDashboard.putBoolean("Left?", left);

        //measure left or right encoders, as applicable
        if (left)
            currentLocation = RevolutionsToInches(TicksToRevolution(Robot.driveTrain.getLeftEncoderPosition()));
        else
            currentLocation = RevolutionsToInches(TicksToRevolution(Robot.driveTrain.getRightEncoderPosition()));
        
        currentLocation = Math.abs(currentLocation);

        SmartDashboard.putNumber("Arc target", arcLength);
        SmartDashboard.putNumber("currentDistance", currentLocation);

        //PID measurements
        error = arcLength - currentLocation;
        integral += error * .02;
        derivative = (error - previousError) / .02;
        previousError = error;

        SmartDashboard.putNumber("Drive Arc Error", error);

        //  Welcome to the Amazing World of PID :D
        speed = RobotMap.DRIVE_kP * error + RobotMap.DRIVE_kI * integral + RobotMap.DRIVE_kD * derivative;
        speed *= -1;
        if (Math.abs(error) < 10)
            complete = true;
    }

    @Override
    protected boolean isFinished() {
        return complete || Robot.oi.getXbox1().getTriggerAxis(GenericHID.Hand.kLeft) != 0 || Robot.oi.getXbox1().getTriggerAxis(GenericHID.Hand.kRight) != 0;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.driveTrain.stop();
    }

    // Called when another command which requires one or more of the same
    // sub//Systems is scheduled to run
    @Override
    protected void interrupted() {
        end();
    }
}
